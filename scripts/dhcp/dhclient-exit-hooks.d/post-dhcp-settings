#!/bin/bash
#
. /usr/local/sbin/networking_defs.sh

PATH=/sbin:/usr/local/bin:$PATH
ROUTE_INFO_PATH=/var/lib/routes
TIME_TRESHOLD=30
ETH0_DY_NAME=gw.asuka.dy.fi
ETH1_DY_NAME=shell.asuka.dy.fi
ETH2_DY_NAME=asuka.dy.fi

LOCK_WAIT_SECS=15



# Only update if
# 1. Bound (update everything)
# 2. Otherwise if old ip address is different than current or
#    old routers is different than current

# Get new routers from file, if time difference small enough
new_file_routers=""
TIME_DIFF=$((`date +%s` - `stat -c %Y $ROUTE_INFO_PATH/$interface.dat`))

if [ $TIME_DIFF -lt $TIME_TRESHOLD ];
then
    new_file_routers=$(head -n 1 $ROUTE_INFO_PATH/$interface.dat)
fi

case $reason in
    BOUND|RENEW|REBIND|REBOOT|TIMEOUT)

	logger "Interface $interface entering lock contest"
	sync

	# Force only one script to execute at a time

	LOCK_TRY_TIME=0

	while [ $LOCK_TRY_TIME -lt $LOCK_WAIT_SECS ];
	do
	    if mkdir $SCRIPTS_LOCKDIR;
	    then
		# Lock acquired
		break;
	    else
		# Lock not acquired, wait and try again
		sleep 1;
		LOCK_TRY_TIME=$(( LOCK_TRY_TIME+1 ));
	    fi
	done

	if [ $LOCK_TRY_TIME -ge $LOCK_WAIT_SECS ];
	then
	    logger "Interface $interface could not get a lock! Exiting.";
	    sync;
	    exit 1;
	fi

	logger "Interface $interface has lock"
	sync



	# Usual case: First ones are BOUND, rest RENEW
	
	if [ "$interface" = "eth0" ];
	then
	    if [ $reason = "BOUND" -o $reason = "REBOOT" ];
	    then
		/usr/local/sbin/setup_vpn.sh
		/usr/local/sbin/firewall_vpn.sh
		logger "$interface ($reason): Settings: IP: $old_ip_address -> $new_ip_address; GW: $old_routers -> $new_file_routers"
	    elif [ $old_ip_address != $new_ip_address -o $old_routers != $new_file_routers ];
	    then
		/usr/local/sbin/setup_vpn.sh
		/usr/local/sbin/firewall_vpn.sh
		logger "$interface ($reason): Changes: IP: $old_ip_address -> $new_ip_address; GW: $old_routers -> $new_file_routers"
	    else
		logger "$interface ($reason): No changes: IP: $old_ip_address -> $new_ip_address; GW: $old_routers -> $new_file_routers"
	    fi
	    /usr/local/sbin/update_dy_fi_address.sh $interface $ETH0_DY_NAME
	fi
	if [ "$interface" = "eth1" ];
	then
	    if [ $reason = "BOUND" -o $reason = "REBOOT" ];
	    then
		/usr/local/sbin/policy_route_dhcp.sh $interface
		/usr/local/sbin/firewall_shell.sh
		logger "$interface ($reason): Settings: IP: $old_ip_address -> $new_ip_address; GW: $old_routers -> $new_file_routers"
	    elif [ $old_ip_address != $new_ip_address -o $old_routers != $new_file_routers ];
	    then
		/usr/local/sbin/policy_route_dhcp.sh $interface
		/usr/local/sbin/firewall_shell.sh
		logger "$interface ($reason): Changes: IP: $old_ip_address -> $new_ip_address; GW: $old_routers -> $new_file_routers"
	    else
		logger "$interface ($reason): No changes: IP: $old_ip_address -> $new_ip_address; GW: $old_routers -> $new_file_routers"
	    fi
	    /usr/local/sbin/update_dy_fi_address.sh $interface $ETH1_DY_NAME
	fi
	
	if [ "$interface" = "eth2" ];
	then

	    if [ $reason = "BOUND" -o $reason = "REBOOT" ];
	    then
		/usr/local/sbin/policy_route_dhcp.sh $interface
		/usr/local/sbin/firewall_asuka.sh
		logger "$interface ($reason): Settings: IP: $old_ip_address -> $new_ip_address; GW: $old_routers -> $new_file_routers"
	    elif [ $old_ip_address != $new_ip_address -o $old_routers != $new_file_routers ];
	    then
		/usr/local/sbin/policy_route_dhcp.sh $interface
		/usr/local/sbin/firewall_asuka.sh
		logger "$interface ($reason): Changes: IP: $old_ip_address -> $new_ip_address; GW: $old_routers -> $new_file_routers"
	    else
		logger "$interface ($reason): No changes: IP: $old_ip_address -> $new_ip_address; GW: $old_routers -> $new_file_routers"
	    fi
	    /usr/local/sbin/update_dy_fi_address.sh $interface $ETH2_DY_NAME
	fi

	# Releasing the lock
	logger "Interface $interface exiting"
	sync
	rmdir $SCRIPTS_LOCKDIR
	;;

esac



